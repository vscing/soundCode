<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Object对象系列属性方法</title>
</head>
<body>
  <script type="text/javascript">
    /** 
     * Object.prototype.constructor
     * 返回创建实例对象的 Object 构造函数的引用。注意，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串。对原始类型来说，如1，true和"test"，该值只可读。
    */
    function Tree(name) {
      this.name = name;
    }
    let obj = new Tree('test');
    console.dirxml(obj, obj.constructor);

    /**
     * Object.assign()
     * Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。
     * Object.assign(target, ...sources)
     * 目标对象。属于浅拷贝
    */
    let target = { a: { d: 1 }, b: { c: 2 } };
    let source = { b: 4, c: 5 };

    let returnedTarget = Object.assign(target, source);
    target.a.d = 3;
    console.log(returnedTarget);

    /** 
     * Object.create()
     * Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
     * 
    */
    let Person = {
      isHuman: false,
      printIntroduction: function() {
        console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
      }
    };
    let me = Object.create(Person);
    console.dirxml(me);
    Person.prototype = { age:24 };
    let me2 = Object.create(Person.prototype);
    console.dirxml(me2);
    function Parent(){
      this.name = "i am parent";
    }
    Parent.prototype = {age:24};
    Parent.prototype.constructor = Parent;
    function Child(){
      this.name = "i am child";
    }
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
    let child = new Child();
    console.dirxml(child);

    // Shape - 父类(superclass)
    function Shape() {
      this.x = 0;
      this.y = 0;
    }

    // 父类的方法
    Shape.prototype.move = function(x, y) {
      this.x += x;
      this.y += y;
      console.info('Shape moved.');
    };

    // Rectangle - 子类(subclass)
    function Rectangle() {
      Shape.call(this); // call super constructor.
    }

    // 子类续承父类
    console.dirxml(Shape.prototype, Object.create(Shape.prototype))
    Rectangle.prototype = Object.create(Shape.prototype);
    Rectangle.prototype.constructor = Rectangle;

    let rect = new Rectangle();
    console.dirxml(rect);
    console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true
    console.log('Is rect an instance of Shape?', rect instanceof Shape); // true
    rect.move(1, 1); // Outputs, 'Shape moved.'

    /**
     * Object.defineProperties()
     * Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。
     * Object.defineProperties(obj, props) 如已设置 set 或 get, 就不能设置 writable 和 value 中的任何一个了
     * 传递给函数的对象。
    */
    obj = {};
    Object.defineProperties(obj, {
      'prototype1': {
        configurable: false, // 只有该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。
        enumerable: true, // 只有在枚举相应对象上的属性时该属性显现。
        writable: true, // 只有与该属性相关联的值被assignment operator (en-US)改变时
        value: true, // 默认值
        // 作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。
        // get(){

        // },
        // 作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。
        // set(v){

        // }
      },
      'prototype2': {
        value: 'Hello',
        writable: false,
        // get(){

        // },
        // set(v){
          
        // }
      }
    });
    obj.prototype1 = false;
    console.log(obj);
    // Object.defineProperties(obj, {
    //   'prototype2': {
    //     configurable: true
    //   }
    // });  

    /** 
     * Object.defineProperty()
     * Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
     * Object.defineProperty(obj, prop, descriptor)
     * 被传递给函数的对象。
    */
    let o = {};
    o.a = 1;
    // 等同于：
    Object.defineProperty(o, "a", {
      value: 1,
      writable: true,
      configurable: true,
      enumerable: true
    });

    // 另一方面，
    Object.defineProperty(o, "a", { value : 1 });
    // 等同于：
    Object.defineProperty(o, "a", {
      value: 1,
      writable: true,
      configurable: true,
      enumerable: true
    });

    o.obj = null;
    o.arr = null;

    Object.defineProperty(o, 'obj', {
      configurable: true,
      enumerable: true,
      get: function() {
        console.log('get!');
      },
      set: function(value) {
        console.log(value);
      }
    });
    o.obj.c = 456
    console.log(o.obj.c);


    Object.defineProperty(o, 'arr', {
      configurable: true,
      enumerable: true,
      get: function() {
        console.log('get!');
      },
      set: function(value) {
        console.log(value);
      }
    });
    o.arr = [1,2,3];
    o.arr.push(2);
    console.log(o.arr);
    
    



  </script>
</body>
</html>
